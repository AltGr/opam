(**************************************************************************)
(*                                                                        *)
(*    Copyright 2017-2019 OCamlPro                                        *)
(*                                                                        *)
(*  All rights reserved. This file is distributed under the terms of the  *)
(*  GNU Lesser General Public License version 2.1, with the special       *)
(*  exception on linking described in the file LICENSE.                   *)
(*                                                                        *)
(**************************************************************************)

(* This is a simplified version of the Z3 backend, that assumes only one version
   of a given package can be installed at a single time. That assumption is
   always enforced in opam, but is not mandatory in CUDF, making this solver
   backend less general.

   This allows us to encode packages as integers, 0 meaning uninstalled and >0
   integers corresponding to the chosen CUDF version. The encoding of
   constraints through inequations becomes then much more natural, avoiding long
   disjunctions of many possible cases. The more generic implementation has one
   boolean variable for every package version. *)

open OpamCudfSolverSig

let log f = OpamConsole.log "Z3" f

let name = "builtin-z3bis"

let ext = ref None

let is_present () = true

let command_name = None

let default_criteria = {
  crit_default = "-removed,\
                  -count[avoid-version,changed],\
                  -count[version-lag,request],\
                  -count[version-lag,changed],\
                  -count[missing-depexts,changed],\
                  -changed";
  crit_upgrade = "-removed,\
                  -count[avoid-version,changed],\
                  -count[version-lag,solution],\
                  -count[missing-depexts,changed],\
                  -new";
  crit_fixup = "-changed,\
                -count[avoid-version,changed],\
                -count[version-lag,solution],\
                -count[missing-depexts,changed]";
  crit_best_effort_prefix = Some "+count[opam-query,solution],";
}

let mk_or ctx = function
  | None -> None
  | Some [] -> None
  | Some [p] -> Some p
  | Some l -> Some (Z3.Boolean.mk_or ctx l)

let mk_and ctx = function
  | None -> None
  | Some [] -> None
  | Some [p] -> Some p
  | Some l -> Some (Z3.Boolean.mk_and ctx l)

let ( @^ ) opt l = match opt with
  | None -> l
  | Some x -> x :: l

let (@@^) o l = match o with
  | None -> l
  | Some l1 -> List.rev_append l1 l

let xrmap f l =
  match List.fold_left (fun acc x -> f x @^ acc) [] l with
  | [] -> None
  | l -> Some l

(*
let xmap f l = match xrmap f l with
  | Some l -> Some (List.rev l)
  | None -> None
*)
open OpamStd.Option.Op

module P (SYM: sig
    val ctx: Z3.context
    val psym: string -> Z3.Expr.expr option
end) = struct
  open SYM

  let pconstr name constr v = match psym name with
    | None -> Z3.Boolean.mk_false ctx
    | Some ps -> constr ctx ps (Z3.Arithmetic.Integer.mk_numeral_i ctx v)

  let pveq name v = pconstr name Z3.Boolean.mk_eq v

  let peq p = pveq p.Cudf.package p.Cudf.version

  let pvneq name v = Z3.Boolean.mk_not ctx (pveq name v)

  let pneq p = Z3.Boolean.mk_not ctx (peq p)

  let pinstalled name = pconstr name Z3.Arithmetic.mk_gt 0

  let psym_exn name = match psym name with
    | None -> raise Not_found
    | Some p -> p

  let expand_constraint (name, constr) =
    OpamStd.Option.some @@
    match constr with
    | None -> pinstalled name
    | Some (`Eq, v) -> pveq name v
    | Some (`Geq, v) -> pconstr name Z3.Arithmetic.mk_ge v
    | Some (`Gt, v) -> pconstr name Z3.Arithmetic.mk_gt v
    | Some ((`Neq|`Leq|`Lt) as op, v) ->
      Z3.Boolean.mk_and ctx [
        pinstalled name;
        match op with
        | `Neq -> pvneq name v
        | `Leq -> pconstr name Z3.Arithmetic.mk_le v
        | `Lt -> pconstr name Z3.Arithmetic.mk_lt v
      ]
end

let def_packages ctx (_preamble, universe, _request) =
  let syms = Hashtbl.create 2731 in
  let psym name = Hashtbl.find_opt syms name in
  let open P(struct let ctx = ctx let psym = psym end) in
  (* variable definitions *)
  let def_exprs = [] in
  let def_exprs =
    Cudf.fold_packages_by_name (fun e name pkgs ->
        Hashtbl.add syms name
          (Z3.Arithmetic.Integer.mk_const_s ctx name);
        let bounds =
          let versions = List.map (fun p -> p.Cudf.version) pkgs in
          let vlist = List.sort (fun a b -> compare b a) (0 :: versions) in
          let maxv = List.hd vlist in
          if List.length vlist - 2 <= maxv / 2 then
            Z3.Boolean.mk_or ctx
              (List.rev_map (fun v -> pveq name v) vlist)
          else
          let rec allv i = if i < 0 then [] else i :: allv (i-1) in
          Z3.Boolean.mk_and ctx
            (pconstr name Z3.Arithmetic.mk_ge 0 ::
             (List.filter_map (fun v ->
                  if List.mem v vlist then None
                  else Some (pvneq name v))
                 (allv maxv)) @
             [pconstr name Z3.Arithmetic.mk_le maxv])
        in
        bounds :: e)
      def_exprs
      universe
  in
  let def_exprs =
    (* "keep" flags *)
    Cudf.fold_packages_by_name (fun e name pkgs ->
        let keep =
          match List.find (fun p -> p.Cudf.keep = `Keep_version) pkgs with
          | p -> Some (peq p)
          | exception Not_found ->
            if List.exists (fun p -> p.Cudf.keep = `Keep_package) pkgs then
              Some (pinstalled name)
            else None
        in
        keep @^ e)
      def_exprs
      universe
  in
  let def_exprs =
    (* dependencies *)
    Cudf.fold_packages (fun e pkg ->
        let depends =
          xrmap
            (fun disj -> mk_or ctx @@ xrmap expand_constraint disj)
            pkg.Cudf.depends
          |> mk_and ctx
          >>| Z3.Boolean.mk_implies ctx (peq pkg)
        in
        let conflicts =
          mk_or ctx @@ xrmap
             expand_constraint
             (List.filter (fun (p,_) -> p <> pkg.Cudf.package) pkg.Cudf.conflicts)
          >>| fun c ->
          Z3.Boolean.mk_implies ctx (peq pkg) (Z3.Boolean.mk_not ctx c)
        in
        depends @^ conflicts @^ e)
      def_exprs
      universe
  in
  List.rev def_exprs,
  psym

let def_request ctx (_preamble, universe, request) psym =
  let open P(struct let ctx = ctx let psym = psym end) in
  let inst =
    xrmap expand_constraint request.Cudf.install
  in
  let rem =
    xrmap
      (fun vpkg -> expand_constraint vpkg >>| Z3.Boolean.mk_not ctx)
      request.Cudf.remove
  in
  let up =
    xrmap (fun ((name, c) as req) ->
        match Cudf.get_installed universe name with
        | [] ->
          expand_constraint req
        | p::_ -> (* assumed to be singleton in our case *)
          (match c with
           | None -> fun e -> Some e
           | c -> fun e -> mk_and ctx (Some [e; Option.get (expand_constraint req)]))
          @@
          Option.get @@ expand_constraint (name, Some (`Geq, p.Cudf.version)))
      request.Cudf.upgrade
  in
  inst @@^ rem @@^ up @@^ []
(*
let sum ctx (_, universe, _) filter value =
  let zero = Z3.Arithmetic.Integer.mk_numeral_i ctx 0 in
  Cudf.fold_packages_by_name (fun e name versions ->
      match filter name with
      | None -> e
      | Some filt ->
        match value name with
        | None -> e
        | Some n ->
          if Z3.Boolean.is_not filt then
            match Z3.Expr.get_args filt with
            | [filt] -> Z3.Boolean.mk_ite ctx filt zero n :: e
            | _ -> assert false
          else
            Z3.Boolean.mk_ite ctx filt n zero :: e)
    []
    universe
*)
type filter = Installed | Changed | Removed | New | Upgraded | Downgraded | Requested
type property = string option
type sign = Plus | Minus

type criterion = sign * filter * property

let def_criterion ctx opt (preamble, universe, request as cudf) psym
    (sign, filter, property : criterion) =
  let open P(struct let ctx = ctx let psym = psym end) in
  let integer i = Z3.Arithmetic.Integer.mk_numeral_i ctx i in
  let zero = integer 0 in
  let filter_f prop propjoin = match filter with
    | Installed ->
      fun name _ -> prop name (psym_exn name)
    | Changed ->
      fun name pkgs ->
        let inst_v =
          try (List.find (fun p -> p.Cudf.installed) pkgs).Cudf.version
          with Not_found -> 0
        in
        Z3.Boolean.mk_ite ctx (pveq name inst_v) (prop name zero)
          (propjoin [ prop name (psym_exn name);
                      prop name (integer inst_v) ])
    | Removed ->
      (fun name pkgs ->
         match List.find (fun p -> p.Cudf.installed) pkgs with
         | inst_p -> prop name (integer inst_p.Cudf.version)
         | exception Not_found -> zero)
    | New ->
      (fun name pkgs ->
         match List.find (fun p -> p.Cudf.installed) pkgs with
         | _inst_p -> zero
         | exception Not_found -> prop name (psym_exn name))
    | Upgraded ->
      (fun name pkgs ->
         match List.find (fun p -> p.Cudf.installed) pkgs with
         | inst_p ->
           Z3.Boolean.mk_ite ctx
             (pconstr name Z3.Arithmetic.mk_gt inst_p.Cudf.version)
             (prop name (psym_exn name))
             zero
         | exception Not_found -> zero)
    | Downgraded ->
      (fun name pkgs ->
         match List.find (fun p -> p.Cudf.installed) pkgs with
         | inst_p ->
           Z3.Boolean.mk_ite ctx
             (pconstr name Z3.Arithmetic.mk_lt inst_p.Cudf.version)
             (prop name (psym_exn name))
             zero
         | exception Not_found -> zero)
    | Requested ->
      (fun name _ ->
         if List.exists (fun (n, _) -> n = name) request.Cudf.install ||
            List.exists (fun (n, _) -> n = name) request.Cudf.upgrade
         then prop name (psym_exn name)
         else zero)
  in
  let value_f = match property with
    | None ->
      fun name v ->
        if v = zero then zero
        else Z3.Boolean.mk_ite ctx (pconstr name Z3.Arithmetic.mk_gt 0) (integer 1) zero
    | Some prop ->
      let prop_values name =
        List.map (fun p ->
            p.Cudf.version,
            match Cudf.lookup_typed_package_property p prop with
            | `Int n | `Nat n -> n
            | `Bool true -> 1
            | `Bool false -> 0
            | _ -> 0
            | exception Not_found ->
              match List.assoc prop preamble.Cudf.property with
              | `Int (Some n) | `Nat (Some n) -> n
              | `Bool (Some true) -> 1
              | `Bool (Some false) -> 0
              | _ -> 0
              | exception Not_found ->
                failwith ("Undefined CUDF property: "^prop))
          (Cudf.lookup_packages universe name)
      in
      (* fixme: simplify what this generates (esp. for version-lag) *)
      fun name v ->
        List.fold_left (fun acc (vers, param) ->
            if param = 0 then acc else
              Z3.Boolean.mk_ite ctx (Z3.Boolean.mk_eq ctx v (integer vers))
                (integer param)
                acc)
          zero
          (prop_values name)
  in
  let crits =
    Cudf.fold_packages_by_name (fun e name pkgs ->
        filter_f value_f (Z3.Arithmetic.mk_add ctx) name pkgs
        :: e)
      []
      universe
  in
  OpamStd.Option.some @@
  (match sign with Plus -> Z3.Optimize.maximize | Minus -> Z3.Optimize.minimize)
    opt
    (Z3.Arithmetic.mk_add ctx crits)

let def_criteria ctx opt cudf psym crits =
  List.map (def_criterion ctx opt cudf psym) crits

module Syntax = struct

  let criterion_of_string (s,params) =
    let sign = match s.[0] with
      | '+' -> Plus
      | '-' -> Minus
      | c -> failwith (Printf.sprintf "criteria_of_string sign=%c" c)
      | exception Invalid_argument _ ->
        failwith "criteria_of_string sign=EOF"
    in
    let s = String.sub s 1 (String.length s - 1) in
    let subset_of_string = function
      | "new" -> New
      | "removed" -> Removed
      | "changed" -> Changed
      | "up" -> Upgraded
      | "down" -> Downgraded
      | "installed" | "solution" -> Installed
      | "request" -> Requested
      | s -> failwith ("criteria_of_string subset="^s)
    in
    match s, params with
    | "count", [field; subset] ->
      sign, subset_of_string subset, Some field
    | s, [] -> sign, subset_of_string s, None
    | s, _ -> failwith ("criteria_of_string s="^s)
(*
  let string_of_criterion (sign, filter, property: criterion) =
    Printf.sprintf "%c%s%s"
      (match sign with Plus -> '+' | Minus -> '-')
      (match filter with
       | Installed -> "installed"
       | Changed -> "changed"
       | Removed -> "removed"
       | New -> "new"
       | Upgraded -> "up"
       | Downgraded -> "down"
       | Requested -> "request")
      (match property with None -> "" | Some p -> "["^p^"]")
*)
  let criteria_of_string s =
    let start = ref 0 in
    let crits = ref [] in
    let params = ref None in
    for i = 0 to String.length s - 1 do
      match s.[i] with
      | ',' ->
        let sub = String.sub s !start (i - !start) in
        start := i + 1;
        if sub <> "" then
          (match !params with
           | None -> crits := (sub, []) :: !crits
           | Some (name, ps) -> params := Some (name, sub :: ps))
      | '[' ->
        let sub = String.sub s !start (i - !start) in
        start := i + 1;
        if !params <> None then failwith "criteria_of_string";
        params := Some (sub, [])
      | ']' ->
        let sub = String.sub s !start (i - !start) in
        start := i + 1;
        (match !params with
         | None -> failwith "criteria_of_string"
         | Some (name, ps) ->
           params := None;
           crits := (name, List.rev (sub::ps)) :: !crits)
      | _ -> ()
    done;
    if !start < String.length s then
      crits := (String.sub s !start (String.length s - !start), []) :: !crits;
    if !params <> None then failwith "criteria_of_string";
    let r = List.rev_map criterion_of_string !crits in
    r

end

let extract_solution_packages universe opt =
  match Z3.Optimize.get_model opt with
  | Some model ->
    Z3.Model.get_const_decls model |>
    List.fold_left (fun pkgs decl ->
        match Z3.Model.get_const_interp model decl with
        | Some v ->
          let v = Z.to_int (Z3.Arithmetic.Integer.get_big_int v) in
          if v > 0 then
            let name = Z3.Symbol.get_string (Z3.FuncDecl.get_name decl) in
            let p = Cudf.lookup_package universe (name, v) in
            {p with
             Cudf.was_installed = p.installed;
             Cudf.installed = true}
            :: pkgs
          else pkgs
        | _ -> pkgs)
      []
  | None -> failwith "no model ??"

let call ~criteria ?timeout (preamble, universe, _ as cudf) =
  (* try *)
  log "Generating problem...";
  let cfg = match timeout with
    | None -> []
    | Some secs -> ["timeout", string_of_int (int_of_float (1000. *. secs))]
  in
  let ctx = Z3.mk_context cfg in
  let opt = Z3.Optimize.mk_opt ctx in
  log "Generating package definitions";
  let expr, psym = def_packages ctx cudf in
  Z3.Optimize.add opt expr;
  log "Generating request";
  Z3.Optimize.add opt (def_request ctx cudf psym);
  log "Generating optimization criteria";
  let _objs =
    def_criteria ctx opt cudf psym (Syntax.criteria_of_string criteria)
  in
  log "Resolving...";
  (match Sys.getenv "OPAMZ3DEBUG" with
   | exception Not_found -> ()
   | f ->
     let debug = open_out (f^".smt2") in
     output_string debug (Z3.Optimize.to_string opt);
     close_out debug);
  match Z3.Optimize.check opt with
  | UNSATISFIABLE ->
    log "UNSAT";
    raise Common.CudfSolver.Unsat
  | UNKNOWN ->
    log "UNKNOWN";
    (try
       let universe =
         Cudf.load_universe (extract_solution_packages universe opt)
       in
       raise (Timeout (Some (Some preamble, universe)))
     with Failure _ ->
       raise (Timeout None))
  | SATISFIABLE ->
    log "SAT: extracting model";
    let universe =
      Cudf.load_universe (extract_solution_packages universe opt)
    in
    Some preamble, universe
  (* with
   * | (Timeout | Common.CudfSolver.Unsat | Failure _) as e -> raise e
   * | e ->
   *   OpamConsole.error "Z3 error: %s" (Printexc.to_string e);
   *   OpamConsole.errmsg "%s" (Printexc.get_backtrace ());
   *   raise e *)
