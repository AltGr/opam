(**************************************************************************)
(*                                                                        *)
(*    Copyright 2017-2019 OCamlPro                                        *)
(*                                                                        *)
(*  All rights reserved. This file is distributed under the terms of the  *)
(*  GNU Lesser General Public License version 2.1, with the special       *)
(*  exception on linking described in the file LICENSE.                   *)
(*                                                                        *)
(**************************************************************************)

(* This is a simplified version of the Z3 backend, that assumes only one version
   of a given package can be installed at a single time. That assumption is
   always enforced in opam, but is not mandatory in CUDF, making this solver
   backend less general.

   This allows us to encode packages as integers, 0 meaning uninstalled and >0
   integers corresponding to the chosen CUDF version. The encoding of
   constraints through inequations becomes then much more natural, avoiding long
   disjunctions of many possible cases. The more generic implementation has one
   boolean variable for every package version. *)

open OpamCudfSolverSig

let log f = OpamConsole.log "Z3" f

let name = "builtin-z3bis"

let ext = ref None

let is_present () = true

let command_name = None

let default_criteria = {
  crit_default = "-removed,\
                  -count[avoid-version,changed],\
                  -count[version-lag,request],\
                  -count[version-lag,changed],\
                  -count[missing-depexts,changed],\
                  -changed";
  crit_upgrade = "-removed,\
                  -count[avoid-version,changed],\
                  -count[version-lag,solution],\
                  -count[missing-depexts,changed],\
                  -new";
  crit_fixup = "-changed,\
                -count[avoid-version,changed],\
                -count[version-lag,solution],\
                -count[missing-depexts,changed]";
  crit_best_effort_prefix = Some "+count[opam-query,solution],";
}

let mk_or ctx = function
  | None -> None
  | Some [] -> None
  | Some [p] -> Some p
  | Some l -> Some (Z3.Boolean.mk_or ctx l)

let mk_and ctx = function
  | None -> None
  | Some [] -> None
  | Some [p] -> Some p
  | Some l -> Some (Z3.Boolean.mk_and ctx l)

let ( @^ ) opt l = match opt with
  | None -> l
  | Some x -> x :: l

let (@@^) o l = match o with
  | None -> l
  | Some l1 -> List.rev_append l1 l

let xrmap f l =
  match List.fold_left (fun acc x -> f x @^ acc) [] l with
  | [] -> None
  | l -> Some l

(*
let xmap f l = match xrmap f l with
  | Some l -> Some (List.rev l)
  | None -> None
*)
open OpamStd.Option.Op

module P (SYM: sig
    val ctx: Z3.context
    val psym: string -> Z3.Expr.expr option
end) = struct
  open SYM

  let pconstr name constr v = match psym name with
    | None -> Z3.Boolean.mk_false ctx
    | Some ps -> constr ctx ps (Z3.Arithmetic.Integer.mk_numeral_i ctx v)

  let pveq name v = pconstr name Z3.Boolean.mk_eq v

  let peq p = pveq p.Cudf.package p.Cudf.version

  let pvneq name v = Z3.Boolean.mk_not ctx (pveq name v)

  let pneq p = Z3.Boolean.mk_not ctx (peq p)

  let pinstalled name = pconstr name Z3.Arithmetic.mk_gt 0

  let psym_exn name = match psym name with
    | None -> raise Not_found
    | Some p -> p

  let expand_constraint (name, constr) =
    OpamStd.Option.some @@
    match constr with
    | None -> pinstalled name
    | Some (`Eq, v) -> pveq name v
    | Some (`Geq, v) -> pconstr name Z3.Arithmetic.mk_ge v
    | Some (`Gt, v) -> pconstr name Z3.Arithmetic.mk_gt v
    | Some ((`Neq|`Leq|`Lt) as op, v) ->
      Z3.Boolean.mk_and ctx [
        pinstalled name;
        match op with
        | `Neq -> pvneq name v
        | `Leq -> pconstr name Z3.Arithmetic.mk_le v
        | `Lt -> pconstr name Z3.Arithmetic.mk_lt v
      ]
end

let def_packages ctx (_preamble, universe, _request) =
  let syms = Hashtbl.create 2731 in
  let psym name = Hashtbl.find_opt syms name in
  let open P(struct let ctx = ctx let psym = psym end) in
  (* variable definitions *)
  let def_exprs = [] in
  let def_exprs =
    Cudf.fold_packages_by_name (fun e name pkgs ->
        Hashtbl.add syms name
          (Z3.Arithmetic.Integer.mk_const_s ctx name);
        let bounds =
          let versions = List.map (fun p -> p.Cudf.version) pkgs in
          let vlist = List.sort (fun a b -> compare b a) (0 :: versions) in
          let maxv = List.hd vlist in
          if List.length vlist - 2 <= maxv / 2 then
            Z3.Boolean.mk_or ctx
              (List.rev_map (fun v -> pveq name v) vlist)
          else
          let rec allv i = if i < 0 then [] else i :: allv (i-1) in
          Z3.Boolean.mk_and ctx
            (pconstr name Z3.Arithmetic.mk_ge 0 ::
             (List.filter_map (fun v ->
                  if List.mem v vlist then None
                  else Some (pvneq name v))
                 (allv maxv)) @
             [pconstr name Z3.Arithmetic.mk_le maxv])
        in
        bounds :: e)
      def_exprs
      universe
  in
  let def_exprs =
    (* "keep" flags *)
    Cudf.fold_packages_by_name (fun e name pkgs ->
        let keep =
          match List.find (fun p -> p.Cudf.keep = `Keep_version) pkgs with
          | p -> Some (peq p)
          | exception Not_found ->
            if List.exists (fun p -> p.Cudf.keep = `Keep_package) pkgs then
              Some (pinstalled name)
            else None
        in
        keep @^ e)
      def_exprs
      universe
  in
  let def_exprs =
    (* dependencies *)
    Cudf.fold_packages (fun e pkg ->
        let depends =
          xrmap
            (fun disj -> mk_or ctx @@ xrmap expand_constraint disj)
            pkg.Cudf.depends
          |> mk_and ctx
          >>| Z3.Boolean.mk_implies ctx (peq pkg)
        in
        let conflicts =
          mk_or ctx @@ xrmap
             expand_constraint
             (List.filter (fun (p,_) -> p <> pkg.Cudf.package) pkg.Cudf.conflicts)
          >>| fun c ->
          Z3.Boolean.mk_implies ctx (peq pkg) (Z3.Boolean.mk_not ctx c)
        in
        depends @^ conflicts @^ e)
      def_exprs
      universe
  in
  List.rev def_exprs,
  psym

let def_request ctx (_preamble, universe, request) psym =
  let open P(struct let ctx = ctx let psym = psym end) in
  let inst =
    xrmap expand_constraint request.Cudf.install
  in
  let rem =
    xrmap
      (fun vpkg -> expand_constraint vpkg >>| Z3.Boolean.mk_not ctx)
      request.Cudf.remove
  in
  let up =
    xrmap (fun ((name, c) as req) ->
        match Cudf.get_installed universe name with
        | [] ->
          expand_constraint req
        | p::_ -> (* assumed to be singleton in our case *)
          (match c with
           | None -> fun e -> Some e
           | c -> fun e -> mk_and ctx (Some [e; Option.get (expand_constraint req)]))
          @@
          Option.get @@ expand_constraint (name, Some (`Geq, p.Cudf.version)))
      request.Cudf.upgrade
  in
  inst @@^ rem @@^ up @@^ []
(*
let sum ctx (_, universe, _) filter value =
  let zero = Z3.Arithmetic.Integer.mk_numeral_i ctx 0 in
  Cudf.fold_packages_by_name (fun e name versions ->
      match filter name with
      | None -> e
      | Some filt ->
        match value name with
        | None -> e
        | Some n ->
          if Z3.Boolean.is_not filt then
            match Z3.Expr.get_args filt with
            | [filt] -> Z3.Boolean.mk_ite ctx filt zero n :: e
            | _ -> assert false
          else
            Z3.Boolean.mk_ite ctx filt n zero :: e)
    []
    universe
*)
type filter = Installed | Changed | Removed | New | Upgraded | Downgraded | Requested
type property = string option
type sign = Plus | Minus

type criterion = sign * filter * property

(* let rec simplify_condition e =
 *   if Z3.Boolean.is_and e then
 *     let conj = Z3.Expr.get_args e in
 *     List.fold_left (fun acc e ->
 *         let e = simplify_condition e in
 *         if Z3.Boolean.is_
 *   Z3.Expr.simplify (Z3.Boolean.mk_and ctx cond) None in *)

let def_criterion ctx opt (preamble, universe, request as cudf) psym
    (sign, filter, property : criterion) =
  let open P(struct let ctx = ctx let psym = psym end) in
  let integer i = Z3.Arithmetic.Integer.mk_numeral_i ctx i in
  let zero = integer 0 in
  let one = integer 1 in
  let false_ = Z3.Boolean.mk_false ctx in
  let true_ = Z3.Boolean.mk_true ctx in
  let filter_f = match filter with (* name -> [condition, version; ...] *)
    | Installed ->
      fun name -> [ pinstalled name, psym_exn name ]
    | Changed ->
      (fun name ->
         match Cudf.get_installed universe name with
         | [] -> [ pinstalled name, psym_exn name ]
         | p::_ ->
           [ pvneq name p.Cudf.version, integer p.Cudf.version;
             Z3.Boolean.mk_and ctx
               [pinstalled name; pvneq name p.Cudf.version],
             psym_exn name ])
    | Removed ->
       (fun name ->
         match Cudf.get_installed universe name with
         | [] -> []
         | p::_ -> [ Z3.Boolean.mk_not ctx (pinstalled name),
                     integer p.Cudf.version ])
    | New ->
      (fun name ->
         match Cudf.get_installed universe name with
         | [] -> [ pinstalled name, psym_exn name ]
         | p::_ -> [])
    | Upgraded ->
      (fun name ->
         match Cudf.get_installed universe name with
         | [] -> []
         | p::_ ->
           [ pconstr name Z3.Arithmetic.mk_gt p.Cudf.version,
             psym_exn name ])
    | Downgraded ->
      (fun name ->
         match Cudf.get_installed universe name with
         | [] -> []
         | p::_ ->
           [ pconstr name Z3.Arithmetic.mk_lt p.Cudf.version,
             psym_exn name ])
    | Requested ->
      (fun name ->
         if List.exists (fun (n, _) -> n = name) request.Cudf.install ||
            List.exists (fun (n, _) -> n = name) request.Cudf.upgrade
         then [ true_, psym_exn name ]
         else [])
  in
  let ite cond t e =
    if Z3.Expr.equal t e then t else
    let cond = Z3.Expr.simplify (Z3.Boolean.mk_and ctx cond) None in
    if Z3.Boolean.is_true cond then t
    else if Z3.Boolean.is_false cond then e
    else Z3.Boolean.mk_ite ctx cond t e
  in
  let value_f = match property with
    | None ->
      fun name ->
        List.map (fun (cond, v) -> ite [cond] one zero)
          (filter_f name)
    | Some prop ->
      match List.assoc prop preamble.Cudf.property with
      | `Bool (None | Some false) ->
        fun name ->
          List.map (fun (condf, v) ->
              let cond =
                List.filter (fun p ->
                    try Cudf.lookup_typed_package_property p prop = `Bool true
                    with Not_found -> false)
                  (Cudf.lookup_packages universe name)
                |> List.map (fun p -> Z3.Boolean.mk_eq ctx v (integer p.Cudf.version))
                |> Z3.Boolean.mk_or ctx
              in
              ite [condf; cond] one zero)
            (filter_f name)
      | `Bool (Some true) ->
        fun name ->
          List.map (fun (condf, v) ->
              let cond =
                List.filter (fun p ->
                    try Cudf.lookup_typed_package_property p prop = `Bool false
                    with Not_found -> false)
                  (Cudf.lookup_packages universe name)
                |> List.map (fun p -> Z3.Boolean.mk_eq ctx v (integer p.Cudf.version))
                |> Z3.Boolean.mk_or ctx
                |> Z3.Boolean.mk_not ctx
              in
              ite [condf; cond] one zero)
            (filter_f name)
      | `Int default | `Nat default ->
        fun name ->
          let vmap =
            List.map (fun p ->
                p.Cudf.version,
                match Cudf.lookup_typed_package_property p prop with
                | `Int n | `Nat n -> n
                | _ -> failwith ("Invalid CUDF property: "^prop)
                | exception Not_found ->
                  match default with Some d -> d | None ->
                    failwith ("Missing CUDF property: "^prop))
              (Cudf.lookup_packages universe name)
          in
          let maxv = List.fold_left (fun acc (v, _) -> max acc v) 0 vmap in
          if List.for_all (fun (v, prop) -> prop = maxv - v) vmap &&
             List.length vmap >= 2 then
            (* Optimisation for version-lag *)
            List.map (fun (condf, v) ->
                ite [condf]
                  (Z3.Arithmetic.mk_sub ctx [integer maxv; v])
                  zero)
              (filter_f name)
          else
          let revmap =
            List.fold_left (fun acc (v, p) ->
                OpamStd.IntMap.update p (fun l -> v::l) [] acc)
              OpamStd.IntMap.empty
              vmap
          in
          List.fold_left (fun acc (condf, v) ->
              OpamStd.IntMap.fold (fun pval vs acc ->
                  ite [condf;
                       Z3.Boolean.mk_or ctx (List.map (pveq name) vs)]
                    (integer pval)
                    zero
                  :: acc)
                revmap
                acc)
            []
            (filter_f name)
      | _ -> failwith ("Can't optimise on non bool/int CUDF property: "^prop)
  in
  let crits =
    Cudf.fold_packages_by_name (fun acc name _ ->
        let cs = value_f name in
        List.rev_append
          (List.filter (fun c -> c <> zero) cs)
          acc)
      [] universe
  in
  match crits with
  | [] -> None
  | cs ->
    Some
      ((match sign with Plus -> Z3.Optimize.maximize | Minus -> Z3.Optimize.minimize)
         opt
         (Z3.Arithmetic.mk_add ctx cs))

let def_criteria ctx opt cudf psym crits =
  List.map (def_criterion ctx opt cudf psym) crits

module Syntax = struct

  let criterion_of_string (s,params) =
    let sign = match s.[0] with
      | '+' -> Plus
      | '-' -> Minus
      | c -> failwith (Printf.sprintf "criteria_of_string sign=%c" c)
      | exception Invalid_argument _ ->
        failwith "criteria_of_string sign=EOF"
    in
    let s = String.sub s 1 (String.length s - 1) in
    let subset_of_string = function
      | "new" -> New
      | "removed" -> Removed
      | "changed" -> Changed
      | "up" -> Upgraded
      | "down" -> Downgraded
      | "installed" | "solution" -> Installed
      | "request" -> Requested
      | s -> failwith ("criteria_of_string subset="^s)
    in
    match s, params with
    | "count", [field; subset] ->
      sign, subset_of_string subset, Some field
    | s, [] -> sign, subset_of_string s, None
    | s, _ -> failwith ("criteria_of_string s="^s)
(*
  let string_of_criterion (sign, filter, property: criterion) =
    Printf.sprintf "%c%s%s"
      (match sign with Plus -> '+' | Minus -> '-')
      (match filter with
       | Installed -> "installed"
       | Changed -> "changed"
       | Removed -> "removed"
       | New -> "new"
       | Upgraded -> "up"
       | Downgraded -> "down"
       | Requested -> "request")
      (match property with None -> "" | Some p -> "["^p^"]")
*)
  let criteria_of_string s =
    let start = ref 0 in
    let crits = ref [] in
    let params = ref None in
    for i = 0 to String.length s - 1 do
      match s.[i] with
      | ',' ->
        let sub = String.sub s !start (i - !start) in
        start := i + 1;
        if sub <> "" then
          (match !params with
           | None -> crits := (sub, []) :: !crits
           | Some (name, ps) -> params := Some (name, sub :: ps))
      | '[' ->
        let sub = String.sub s !start (i - !start) in
        start := i + 1;
        if !params <> None then failwith "criteria_of_string";
        params := Some (sub, [])
      | ']' ->
        let sub = String.sub s !start (i - !start) in
        start := i + 1;
        (match !params with
         | None -> failwith "criteria_of_string"
         | Some (name, ps) ->
           params := None;
           crits := (name, List.rev (sub::ps)) :: !crits)
      | _ -> ()
    done;
    if !start < String.length s then
      crits := (String.sub s !start (String.length s - !start), []) :: !crits;
    if !params <> None then failwith "criteria_of_string";
    let r = List.rev_map criterion_of_string !crits in
    r

end

let extract_solution_packages universe opt =
  match Z3.Optimize.get_model opt with
  | Some model ->
    Z3.Model.get_const_decls model |>
    List.fold_left (fun pkgs decl ->
        match Z3.Model.get_const_interp model decl with
        | Some v ->
          let v = Z.to_int (Z3.Arithmetic.Integer.get_big_int v) in
          if v > 0 then
            let name = Z3.Symbol.get_string (Z3.FuncDecl.get_name decl) in
            let p = Cudf.lookup_package universe (name, v) in
            {p with
             Cudf.was_installed = p.installed;
             Cudf.installed = true}
            :: pkgs
          else pkgs
        | _ -> pkgs)
      []
  | None -> failwith "no model ??"

let call ~criteria ?timeout (preamble, universe, _ as cudf) =
  (* try *)
  log "Generating problem...";
  let cfg = match timeout with
    | None -> []
    | Some secs -> ["timeout", string_of_int (int_of_float (1000. *. secs))]
  in
  let ctx = Z3.mk_context cfg in
  let opt = Z3.Optimize.mk_opt ctx in
  log "Generating package definitions";
  let expr, psym = def_packages ctx cudf in
  Z3.Optimize.add opt expr;
  log "Generating request";
  Z3.Optimize.add opt (def_request ctx cudf psym);
  log "Generating optimization criteria";
  let _objs =
    def_criteria ctx opt cudf psym (Syntax.criteria_of_string criteria)
  in
  log "Resolving...";
  (match Sys.getenv "OPAMZ3DEBUG" with
   | exception Not_found -> ()
   | f ->
     let debug = open_out (f^".smt2") in
     output_string debug (Z3.Optimize.to_string opt);
     close_out debug);
  match Z3.Optimize.check opt with
  | UNSATISFIABLE ->
    log "UNSAT";
    raise Common.CudfSolver.Unsat
  | UNKNOWN ->
    log "UNKNOWN";
    (try
       let universe =
         Cudf.load_universe (extract_solution_packages universe opt)
       in
       raise (Timeout (Some (Some preamble, universe)))
     with Failure _ ->
       raise (Timeout None))
  | SATISFIABLE ->
    log "SAT: extracting model";
    let universe =
      Cudf.load_universe (extract_solution_packages universe opt)
    in
    Some preamble, universe
  (* with
   * | (Timeout | Common.CudfSolver.Unsat | Failure _) as e -> raise e
   * | e ->
   *   OpamConsole.error "Z3 error: %s" (Printexc.to_string e);
   *   OpamConsole.errmsg "%s" (Printexc.get_backtrace ());
   *   raise e *)
